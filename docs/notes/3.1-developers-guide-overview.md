# Developer's Guide to RustDHT

## Overview

This document provides a high-level entry point for developers interested in contributing to RustDHT. It covers project structure, development environment setup, architectural patterns, and current technical status.

## Project Structure and Key Files

### Repository Organization

```
RustDHT/
├── src/
│   ├── bin/
│   │   └── server.rs          # Native P2P server
│   └── lib.rs                 # WASM client library
├── www/
│   ├── index.html             # Web interface
│   ├── main.js                # JavaScript integration
│   └── pkg/                   # Compiled WASM output
├── docs/
│   ├── PRD for Decentralized Graph Database_.md
│   ├── arch/main_architecture.md
│   ├── libp2p-browser-communication.md
│   └── notes/                 # Community documentation
├── Cargo.toml                 # Rust dependencies
├── package.json               # Node.js build tools
├── Dockerfile                 # Container configuration
└── fly.toml                   # Cloud deployment config
```

### Core Source Files

#### `src/bin/server.rs` - Native Server

**Purpose**: Rust binary that runs as always-on P2P node

**Key Components:**
- Multi-transport setup (TCP + WebRTC)
- GossipSub messaging behavior
- Ping protocol for health checks
- HTTP health check endpoint
- Event loop processing

**Current Implementation:**
```rust
// Simplified structure
async fn main() {
    // Create keypair and peer ID
    let local_key = identity::Keypair::generate_ed25519();
    
    // Setup transports: TCP + WebRTC
    let tcp_transport = /* ... */;
    let webrtc_transport = /* ... */;
    let transport = tcp_transport.or_transport(webrtc_transport);
    
    // Create behaviors: Ping + GossipSub
    let behaviour = MyBehaviour {
        ping: ping::Behaviour::new(Config::new()),
        gossipsub: gossipsub::Behaviour::new(/* ... */),
    };
    
    // Create swarm and listen
    let mut swarm = Swarm::new(transport, behaviour, local_peer_id, config);
    swarm.listen_on("/ip4/0.0.0.0/udp/9090/webrtc-direct".parse()?)?;
    
    // Event loop
    loop {
        match swarm.select_next_some().await {
            // Handle connection events
            // Handle ping/gossipsub events
            // Log and monitor
        }
    }
}
```

**Key Features:**
- Listens on IPv4 and IPv6
- WebRTC-direct for browser compatibility
- HTTP server on port 8080 for health checks
- Comprehensive event logging

#### `src/lib.rs` - WASM Client

**Purpose**: Browser-compatible P2P node compiled to WebAssembly

**Key Components:**
- WebRTC-websys transport (browser-specific)
- GossipSub for messaging
- Command channel for JavaScript interaction
- Event handling and logging

**Current Implementation:**
```rust
// Simplified structure
#[wasm_bindgen]
pub fn start_client() {
    spawn_local(async move {
        // Create identity
        let local_key = identity::Keypair::generate_ed25519();
        
        // WebRTC transport (browser-only)
        let transport = webrtc_websys::Transport::new(
            webrtc_websys::Config::new(&local_key)
        );
        
        // GossipSub behavior
        let mut gossipsub = gossipsub::Behaviour::new(/* ... */);
        gossipsub.subscribe(&chat_topic)?;
        
        // Create swarm
        let mut swarm = libp2p::Swarm::new(
            transport,
            behaviour,
            local_peer_id,
            Config::with_wasm_executor(),
        );
        
        // Event loop with command channel
        loop {
            futures::select! {
                event = swarm.select_next_some() => {
                    // Handle P2P events
                }
                command = command_receiver.select_next_some() => {
                    // Handle JavaScript commands
                }
            }
        }
    });
}

#[wasm_bindgen]
pub fn connect_to_server(multiaddr: String) {
    // Parse multiaddr and send dial command
}

#[wasm_bindgen]
pub fn send_message(message: String) {
    // Send message via GossipSub
}
```

**Key Features:**
- Exposes functions to JavaScript via wasm_bindgen
- Command channel for async coordination
- Console logging for browser debugging
- Custom events for message passing to JS

#### `www/` - Web Interface

**`index.html`**: User interface
- Status display
- Connection controls
- Message sending interface
- Console log viewer

**`main.js`**: JavaScript integration
- Loads WASM module
- Calls Rust functions
- Handles user interactions
- Displays P2P events

## Development Environment Setup

### Prerequisites

**System Requirements:**
- Operating System: Linux, macOS, or Windows (WSL recommended)
- Rust 2021 edition or later
- Node.js and npm (for web tooling)
- wasm-pack (for WASM compilation)

### Installation Steps

#### 1. Install Rust

```bash
# Via rustup (recommended)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Verify installation
rustc --version
cargo --version
```

#### 2. Add WASM Target

```bash
rustup target add wasm32-unknown-unknown
```

#### 3. Install wasm-pack

```bash
# Linux/macOS
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

# Or via cargo
cargo install wasm-pack

# Verify installation
wasm-pack --version
```

#### 4. Install Node.js Dependencies

```bash
npm install
```

### Building the Project

#### Native Server

```bash
# Development build
cargo build

# Release build (optimized)
cargo build --release

# Run server
cargo run --bin server

# Or run release binary
./target/release/server
```

**Expected Output:**
```
=== RustDHT Signaling Server Starting ===
🔑 Local peer id: 12D3KooW...
🌐 Signaling port: 9090
🌐 HTTP health check port: 8080
=========================================

🚀 Listening on /ip4/0.0.0.0/udp/9090/webrtc-direct
🚀 Listening on /ip6/::/udp/9090/webrtc-direct
```

#### WASM Client

```bash
# Build WASM module
wasm-pack build --target web

# Output in pkg/ directory
ls pkg/
# rustdht.js
# rustdht_bg.wasm
# rustdht.d.ts
# rustdht_bg.wasm.d.ts
```

#### Web Interface

```bash
# Start development server
npm run serve

# Or use any static HTTP server
# python -m http.server 8000
# npx http-server www
```

Access at `http://localhost:8000` (or specified port)

### Development Workflow

#### Making Changes

**1. Edit Source Code:**
- Modify `src/bin/server.rs` or `src/lib.rs`
- Add tests in respective modules

**2. Rebuild:**
```bash
# For native changes
cargo build

# For WASM changes
wasm-pack build --target web
```

**3. Test:**
```bash
# Run unit tests
cargo test

# Run specific test
cargo test test_name

# Run with output
cargo test -- --nocapture
```

**4. Check Code:**
```bash
# Format code
cargo fmt

# Run linter
cargo clippy

# Check without building
cargo check
```

#### Debugging

**Native Server:**
```bash
# Enable logging
RUST_LOG=debug cargo run --bin server

# Or specific modules
RUST_LOG=rustdht=debug,libp2p=info cargo run --bin server
```

**WASM Client:**
- Open browser developer tools
- Check Console tab for logs
- Use browser's debugger
- Check Network tab for WebRTC connections

## Architecture Overview

### Dual-Target Design

RustDHT supports two execution environments:

**Native (Server):**
- Full P2P capabilities
- Always-on network presence
- TCP and WebRTC transports
- Complete DHT participant

**WASM (Browser):**
- Browser-compatible
- WebRTC-only transport
- Local storage for caching
- Can't listen for incoming connections

### Network Architecture

From `docs/arch/main_architecture.md`:

```
Browser Client  ←WebRTC→  Native Server
                          ↕ TCP
Native Client   ←TCP→     Native Server

Browser Client  ←WebRTC→  Browser Client (via signaling)
```

**Communication Patterns:**

**Native-to-Native:**
- Direct TCP connections
- Optional WebRTC
- Full duplex communication

**Browser-to-Native:**
- WebRTC signaling
- Browser initiates connections
- JavaScript-Rust bridge

### Component Interaction

**Transport Layer:**
- Handles network connections
- Protocol abstraction (TCP, WebRTC, WebSockets)
- NAT traversal (STUN/TURN)

**Behavior Layer:**
- Ping: Connection health checks
- GossipSub: Message broadcasting
- (Future) DHT: Data storage

**Storage Layer:**
- Native: File system, databases
- Browser: IndexedDB, localStorage
- Modular backend interface

**Application Layer:**
- Graph data model
- CRDT conflict resolution
- Security and validation

## Current Status and Known Challenges

### What's Working (Sprint 1 Complete)

From `docs/project-progress-report.md`:

✅ **Build Infrastructure:**
- Rust environment for native + WASM
- CI/CD pipeline (GitHub Actions)
- WASM compilation pipeline
- "Hello World" integration

✅ **Native Server (Sprint 2 Partial):**
- libp2p with modern API
- TCP + WebRTC transports
- GossipSub messaging
- Ping protocol
- Production deployment ready

### Current Blockers (Sprint 2)

🚫 **WASM Client Issues:**
- libp2p version compatibility
- WebRTC-websys lagging behind
- Dependency conflicts

**Root Cause:**
```
libp2p = "0.52" uses SwarmBuilder API
libp2p-webrtc-websys compatible with "0.51"
Trait implementation errors from version mismatch
```

**Proposed Solution:**
From progress report:
> "Switch to WebSocket Transport: Replace libp2p-webrtc-websys with libp2p-websocket-websys. Upgrade back to libp2p = "0.52" for modern API consistency."

### Areas Needing Contribution

**High Priority:**
- Resolve WASM client transport issue
- Complete browser-to-server connectivity
- Implement basic DHT storage
- Add integration tests

**Medium Priority:**
- Performance optimization
- Enhanced error handling
- Better logging and monitoring
- Documentation expansion

**Future Development:**
- Advanced CRDT implementations
- Rich query language
- Security layer completion
- Mobile platform support

## Testing Strategy

### Unit Tests

**Location**: Inline with source code

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_node_creation() {
        let node = Node::new("test_soul");
        assert_eq!(node.soul(), "test_soul");
    }
}
```

**Run:**
```bash
cargo test
```

### Integration Tests

**Location**: `tests/` directory (future)

**Planned Coverage:**
- P2P connection establishment
- Message propagation
- Data synchronization
- Conflict resolution

### Browser Testing

**Manual Testing:**
1. Start native server
2. Open web interface
3. Connect from browser
4. Test messaging
5. Verify events

**Automated Testing** (future):
- Selenium/WebDriver
- Headless browser testing
- Cross-browser compatibility

## Contribution Guidelines

### Code Style

**Rust Formatting:**
```bash
# Format code
cargo fmt

# Check formatting
cargo fmt -- --check
```

**Rust Linting:**
```bash
# Run Clippy
cargo clippy

# Treat warnings as errors (CI)
cargo clippy -- -D warnings
```

### Commit Messages

**Format:**
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- feat: New feature
- fix: Bug fix
- docs: Documentation
- test: Testing
- refactor: Code restructuring
- perf: Performance improvement

**Example:**
```
feat(wasm): Add WebSocket transport fallback

Replace WebRTC-websys with WebSocket transport to resolve
compatibility issues with latest libp2p version.

Closes #123
```

### Pull Request Process

1. **Fork** repository
2. **Create branch** for feature/fix
3. **Make changes** with tests
4. **Run checks**:
   ```bash
   cargo test
   cargo fmt
   cargo clippy
   ```
5. **Commit** with clear messages
6. **Push** to fork
7. **Open PR** with description
8. **Address** review feedback
9. **Merge** when approved

### Code Review Expectations

**For Reviewers:**
- Constructive feedback
- Explain reasoning
- Suggest improvements
- Acknowledge good work

**For Authors:**
- Respond to comments
- Make requested changes
- Ask for clarification
- Be patient and respectful

## Resources for Contributors

### Internal Documentation

**Essential Reading:**
- `README.md` - Project overview
- `docs/arch/main_architecture.md` - Architecture
- `docs/PRD for Decentralized Graph Database_.md` - Complete spec
- `docs/project-progress-report.md` - Current status

**Technical Deep Dives:**
- `docs/libp2p-browser-communication.md` - WebRTC details
- `docs/Decentralized Database Feasibility Analysis_.md` - Analysis
- Sprint plans for phased roadmap

### External Resources

**Rust Learning:**
- The Rust Book: [https://doc.rust-lang.org/book/]
- Rust by Example: [https://doc.rust-lang.org/rust-by-example/]
- Rustlings: [https://github.com/rust-lang/rustlings]

**WebAssembly:**
- Rust and WebAssembly Book: [https://rustwasm.github.io/docs/book/]
- wasm-bindgen Guide: [https://rustwasm.github.io/docs/wasm-bindgen/]

**libp2p:**
- libp2p Documentation: [https://docs.libp2p.io/]
- rust-libp2p Examples: [https://github.com/libp2p/rust-libp2p/tree/master/examples]

**Distributed Systems:**
- GunDB Documentation: [https://gun.eco/docs/]
- CRDT papers and implementations
- Distributed systems literature

## Next Steps

### For New Contributors

1. **Set up environment**
2. **Build and run** examples
3. **Read** architecture docs
4. **Pick** a small issue
5. **Ask questions** in discussions

### For Experienced Contributors

1. **Review** open issues
2. **Propose** improvements
3. **Tackle** complex features
4. **Mentor** newcomers
5. **Shape** project direction

## Conclusion

RustDHT combines cutting-edge technology (Rust, WASM, libp2p) with proven patterns (DHT, CRDT, graph models) to create a practical decentralized database. As a developer, you have the opportunity to work on interesting technical challenges while contributing to digital infrastructure that prioritizes user ownership and community governance.

The project is in active development with a clear roadmap and welcoming community. Your contributions—whether code, documentation, testing, or discussion—help build the decentralized web we want to see.

## Further Reading

### Next in Series
- `3.2-advanced-concepts.md` - Deep technical dives
- `2.2-use-cases-and-applications.md` - What you can build
- `2.3-community-participation.md` - Ways to contribute

### Technical References
- Source code with inline documentation
- Architecture diagrams in docs/arch/
- Sprint plans for feature roadmap
- Progress reports for current status

