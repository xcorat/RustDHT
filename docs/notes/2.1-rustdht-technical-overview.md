# RustDHT Technical Overview

## Overview

This document provides an accessible explanation of RustDHT's key technological components, demonstrating how they enable the vision of community-owned, decentralized infrastructure. The focus is on making complex technical concepts understandable while showing their practical implications.

## Peer-to-Peer Networks and libp2p

### What is a Peer-to-Peer Network?

In traditional client-server architectures, clients request services from centralized servers. In peer-to-peer (P2P) networks, every participant (peer) has equivalent capabilities and can both provide and consume resources.

**Key Characteristics:**
- No distinction between "clients" and "servers"
- Resources shared directly among peers
- Processing load distributed across all nodes
- No single point of control or failure

### How libp2p Facilitates P2P

libp2p is a modular networking framework that provides the foundation for building P2P applications. It's used by major projects including IPFS, Ethereum 2.0, and Polkadot.

**Core Capabilities:**

**Transport Abstraction:**
- Supports multiple protocols: TCP, WebRTC, WebSockets, QUIC
- Applications don't need to know underlying transport
- Can switch or combine transports seamlessly

**Peer Discovery:**
- DHT-based discovery (Kademlia)
- Bootstrap nodes for initial network entry
- mDNS for local network discovery
- Rendezvous protocols for coordination

**Connection Security:**
- Encrypted connections by default
- Noise protocol for secure handshakes
- Peer authentication via cryptographic identities

**Stream Multiplexing:**
- Multiple logical streams over single connection
- Yamux protocol for efficient multiplexing
- Reduces connection overhead

### RustDHT's Use of libp2p

From the project architecture documentation:

**Native Server Implementation:**
```
Multi-transport listener supporting both TCP and WebRTC
Combined transport stack using or_transport for protocol unification
Event-driven architecture using Tokio for async I/O
```

**WASM Client Implementation:**
```
Browser-compatible P2P node
WebRTC-only transport layer (browser limitation)
Bidirectional communication between JavaScript and Rust
```

This dual-target approach enables:
- **Native-to-Native**: Direct TCP connections for server nodes
- **Browser-to-Native**: WebRTC for browser clients to servers
- **Browser-to-Browser**: WebRTC for direct browser communication (in development)

## Rust and WebAssembly (WASM): Performance and Compatibility

### Why Rust?

Rust is chosen for characteristics critical to database systems:

**Memory Safety Without Garbage Collection:**
- Ownership system prevents memory leaks and data races
- No runtime garbage collection pauses
- Predictable performance characteristics

**Zero-Cost Abstractions:**
- High-level code compiles to efficient machine code
- Performance comparable to C/C++
- Type safety without runtime overhead

**Concurrency Safety:**
- Compiler prevents data races at compile time
- Safe concurrent access to shared data
- Critical for P2P systems with many simultaneous connections

**From RustDHT's PRD:**
> "Rust is chosen for its emphasis on memory safety, performance, and concurrency without requiring a garbage collector. This is particularly important for a P2P system where low-latency, high-throughput operations are desired, and where individual nodes may be unreliable."

### Why WebAssembly?

WebAssembly enables Rust code to run in web browsers at near-native speed.

**Technical Benefits:**

**Near-Native Performance:**
- Compiles to efficient binary format
- Much faster than JavaScript for computational tasks
- Enables complex database operations in browser

**Browser Universality:**
- Supported by all modern browsers
- No plugins or extensions required
- Works on desktop, mobile, and embedded devices

**Code Reuse:**
- Same Rust code runs natively and in browser
- Reduces maintenance burden
- Ensures consistent behavior across platforms

**From RustDHT's PRD:**
> "Compiling the Rust core to WebAssembly allows the database logic to run directly in web browsers at speeds approaching native execution, effectively overcoming many of JavaScript's performance limitations for complex data operations."

### The Rust + WASM Synergy

This combination directly addresses a fundamental challenge: achieving high performance within the constrained browser environment.

**Practical Implications:**

**For Users:**
- Database operations run smoothly in browser
- No performance degradation compared to native apps
- Works on any device with modern browser

**For Developers:**
- Write once, deploy everywhere (native and web)
- Type safety across full stack
- Performance predictability

**Resource Efficiency:**
From the PRD's non-functional requirements:
> "Minimizing the CPU and memory footprint is a paramount concern, particularly for browser-based nodes. This optimization is essential to ensure broad compatibility across diverse user devices and to prevent any degradation of user experience."

## Distributed Hash Tables (DHT): Distributed Storage

### What is a DHT?

A Distributed Hash Table provides decentralized key-value storage across a network of nodes.

**Core Concept:**
- Data identified by keys (typically cryptographic hashes)
- Keys mapped to nodes using consistent hashing
- Each node responsible for subset of key space
- Lookups require no central directory

### How DHTs Work: Kademlia Example

Kademlia, used by libp2p and IPFS, employs several clever techniques:

**XOR Distance Metric:**
- Node IDs and keys exist in same identifier space
- Distance calculated as XOR of two identifiers
- Enables efficient routing: always getting "closer" to target

**Routing Tables:**
- Each node maintains k-buckets (lists of known peers)
- Organized by XOR distance
- Provides O(log n) lookup complexity

**Self-Healing:**
- Nodes continuously refresh routing tables
- Automatically adapts to nodes joining/leaving
- No manual configuration required

### Benefits of DHT-Based Storage

**Sharding:**
From RustDHT's PRD:
> "Each node will be responsible for a specific range of keys, with data sharded across the network based on the hash of the key. This approach allows the DHT to scale to extremely large numbers of nodes."

**Replication:**
> "To ensure fault tolerance and data availability, replication will be implemented. Multiple copies of data will be stored on different nodes, reducing the risk of data loss if individual nodes fail or go offline."

**Scalability:**
- Adding nodes increases total capacity
- Lookup efficiency scales logarithmically
- Network self-organizes without coordination

**Resilience:**
- No single point of failure
- Data survives individual node failures
- Network continues functioning as nodes come and go

### Eventual Consistency Model

RustDHT, like many distributed systems, adopts eventual consistency:

**What This Means:**
- Updates may not be immediately visible everywhere
- All nodes converge to same state over time
- Prioritizes availability and low latency

**Trade-offs:**
From the PRD:
> "This model prioritizes high availability and low latency, which are critical characteristics for a P2P system operating in dynamic network environments."

**Practical Implications:**
- Applications must handle temporary inconsistencies
- Users may see different views briefly
- System guarantees convergence, not immediate consistency

### RustDHT's DHT Implementation

Current architecture:

**Storage Backend:**
- Initial browser storage: IndexedDB for structured data, localStorage for simple KV
- Modular design allows other backends (SQLite-WASM planned)
- Different persistence strategies for browser vs. native nodes

**Browser Storage Limitations:**
From the PRD's analysis:
- localStorage: ~5MB limit
- IndexedDB: varies by browser, ~50% disk space
- Data eviction policies vary
- "Persistent" storage requires user permission

**Pragmatic Approach:**
> "Browser-based nodes cannot reliably serve as full replicas for large portions of the decentralized database. Instead, browser storage should be primarily viewed as a local cache for frequently accessed or user-specific data."

This acknowledges reality: browser nodes excel at local-first operation, while dedicated nodes provide network backbone.

## Conflict-Free Replicated Data Types (CRDTs): Seamless Collaboration

### The Problem CRDTs Solve

In distributed systems, especially with offline support, the same data may be modified independently on multiple nodes. How do we merge these changes without losing data or requiring manual conflict resolution?

### CRDT Fundamentals

Conflict-Free Replicated Data Types are data structures designed to merge concurrent updates automatically.

**Key Properties:**

**Monotonicity:**
- State grows without conflicting
- Operations never need to be undone
- Enables deterministic outcomes

**Idempotence:**
- Applying same update multiple times has same effect
- Resilient to message duplication
- Simplifies synchronization

**Commutativity:**
- Order of operations doesn't matter
- Concurrent updates can be applied in any sequence
- Guarantees eventual consistency

### CRDT Types

**Operation-Based CRDTs:**
- Transmit operations (e.g., "increment by 5")
- Require reliable ordered delivery
- Lower bandwidth for small operations

**State-Based CRDTs:**
- Transmit entire state
- Merge function combines states
- More resilient to message loss

### GunDB's HAM Algorithm: RustDHT's Inspiration

GunDB's Hypothetical Amnesia Machine provides sophisticated conflict resolution:

**Key Features:**

**Timestamps and Vector Clocks:**
- Tracks causality of updates
- Machine-relative, not absolute time
- Handles clock inconsistencies

**Last-Write-Wins with Sophistication:**
- Basic strategy: most recent update wins
- Enhanced with vector clocks for ordering
- Deferred updates prevent malicious timestamps

**Offline-First Design:**
From GunDB documentation:
> "HAM's design prioritizes high availability over strong consistency, enabling users to make edits even when completely offline. This design choice inherently precludes the use of traditional group consensus algorithms."

**Strong Eventual Consistency:**
- Guarantees convergence to same state
- Acknowledges temporary inconsistencies
- No centralized coordination required

### RustDHT's CRDT Approach

From the PRD:

**MVP Implementation:**
> "For the MVP, a simple CRDT approach will be implemented, likely a Last-Write-Wins (LWW) Register or a similar operation-based CRDT, which leverages metadata for ordering."

**Extensibility:**
> "The CRDT implementation will be designed with modularity as a core principle, allowing for future extensions beyond the initial simple LWW approach."

**Metadata-Driven:**
Data explicitly holds metadata for:
- Validation rules
- Ownership information
- Conflict resolution methods

This enables self-describing data that can be validated and resolved deterministically across all peers.

### Practical Implications

**For Users:**
- Seamless offline work
- Automatic synchronization
- No "merge conflict" dialogs
- Predictable outcomes

**For Developers:**
- Built-in conflict resolution
- No manual merge code
- Extensible for custom data types
- Interoperable with standard CRDT libraries

**Example Use Case:**
Collaborative document editing:
1. User A edits paragraph 1 offline
2. User B edits paragraph 2 offline
3. Both reconnect to network
4. CRDT automatically merges changes
5. Both see consistent document state

## Graph Data Model: Flexible Structure

### Why a Graph Model?

RustDHT adopts GunDB's graph-based approach for flexibility:

**Advantages Over Relational:**
- No rigid schema required
- Natural representation of relationships
- Easily evolves with application needs
- Efficient traversal of connections

**Advantages Over Document:**
- First-class relationships between entities
- Avoid data duplication
- Query patterns follow natural relationships
- Hypergraph structure for complex relationships

### Core Concepts

**Nodes:**
- Fundamental unit of data
- Contains properties (key-value pairs)
- Has unique identifier ("soul")
- Can link to other nodes

**Soul:**
From the PRD:
> "Each node will possess a unique identifier, referred to as a 'soul' (a term borrowed from Gundb)"

- Globally unique
- Enables direct node references
- Forms basis of graph structure

**Properties:**
- Store primitive values (string, number, boolean, null)
- Or store links to other nodes
- Create edges in the graph

**Links:**
- Special property type
- Points to another node's soul
- Represents relationship/edge

### Example Structure

```
User Node:
{
  "soul": "user_alice",
  "name": "Alice",
  "age": 30,
  "posts": { "#": "post_1", "#": "post_2" }  // Links
}

Post Node:
{
  "soul": "post_1",
  "title": "Hello World",
  "content": "My first post",
  "author": { "#": "user_alice" }  // Link back to user
}
```

This creates a graph: User â†” Posts relationship

### Metadata Fields

Crucially, data includes system metadata:

**Ownership:**
- Public key of data owner
- Determines write permissions
- Enables cryptographic verification

**Validation Rules:**
- Schema or validation logic reference
- Peers use to verify data validity
- Similar to Holochain's DNA rules

**Conflict Resolution:**
- Instructions for CRDT operations
- Timestamp/vector clock information
- Enables deterministic merging

### Flexibility in Practice

**Schema-less Benefits:**
- Add new properties without migrations
- Different nodes can have different fields
- Evolve data model over time
- Application-specific extensions

**Graph Traversal:**
- Follow links to related data
- Efficient queries along relationships
- Natural representation of social graphs, knowledge graphs, etc.

## Communication Protocols: GossipSub and Ping

### GossipSub: Decentralized Messaging

RustDHT uses GossipSub for peer-to-peer message broadcasting.

**Core Concept:**
- Publish/subscribe pattern
- Messages propagate through network gossip
- No central message broker

**How It Works:**
1. Peers subscribe to topics
2. Publishers send messages to topic
3. Messages propagate through mesh network
4. Each subscriber receives message

**Efficiency:**
- Not pure flooding (would waste bandwidth)
- Mesh network of peer connections
- Gossip protocol for redundancy
- Pruning to manage connections

**Current Implementation:**
From `src/lib.rs` and `src/bin/server.rs`:
- Chat topic for message exchange
- 1-second heartbeat interval
- Strict validation mode
- Message authentication via signatures

### Ping Protocol: Connection Health

Simple but essential:
- Verify peer connectivity
- Measure round-trip time (RTT)
- Detect dead connections
- Implemented by libp2p

**RustDHT Usage:**
- Server pings at 1-second intervals
- Client responds to pings
- Logged for monitoring
- Enables connection diagnostics

## Current Technical Status: Honest Assessment

### What's Working

From the project progress report:

**Sprint 1 Complete:**
- Rust environment for native and WASM
- CI/CD pipeline
- WASM compilation working
- JavaScript integration functional

**Sprint 2 Partial:**
- Native server fully operational
- TCP and WebRTC transports
- GossipSub messaging working
- Ping protocol functional
- Health monitoring

### Current Limitations and Challenges

**RustDHT is a Simple Prototype:**
- Not production-ready
- Many core features not yet implemented
- No DHT storage actually working yet (planned)
- No CRDT implementation yet (planned)
- Limited testing and real-world validation

**WASM Client Blocked:**
- libp2p version compatibility issues
- WebRTC-websys lagging behind main libp2p
- Browser support incomplete
- Being addressed through WebSocket fallback

**libp2p Rust Ecosystem Challenges:**
From experience and community feedback:
- Not feature-complete compared to Go implementation
- Browser support still maturing and evolving
- Rapid API changes break compatibility
- Some transports lag behind others
- Documentation can be sparse for advanced features

**Infrastructure Dependency:**
Despite P2P architecture, still requires:
- Bootstrap nodes for initial discovery
- STUN/TURN servers for NAT traversal
- Signaling server for WebRTC
- These are centralized components (for now)

**Centralized Computing Infrastructure:**
The broader reality:
- Cloud providers (AWS, Azure, Google) dominate
- DNS infrastructure centralized
- Certificate authorities centralized
- Internet backbone corporate/state-owned
- Data centers concentrated geographically

### The Path Forward: Start Small, Scale Resilient

**Realistic Approach:**
Rather than claiming to solve all problems, RustDHT:
- Starts with small communities and use cases
- Focuses on specific scenarios where P2P makes sense
- Learns from real-world deployment
- Gradually expands capabilities
- Maintains honest assessment

**The Scaling Advantage:**
Unlike centralized systems that degrade under load, P2P networks become MORE resilient as they grow:
- Each new node adds capacity and redundancy
- Geographic distribution improves naturally
- No single bottleneck
- Network effects work in favor of growth
- Starting small is not a limitation but a strategy

**Pragmatic Engineering:**
Project documentation acknowledges challenges:
> "Switch to WebSocket transport (Recommended): Replace libp2p-webrtc-websys with libp2p-websocket-websys. WebSocket is better maintained and browser-compatible."

This exemplifies the project's philosophy:
- Pragmatic solutions over theoretical purity
- Acknowledge limitations honestly
- Learn from and collaborate with ecosystem
- Focus on what works, iterate on what doesn't

## Architecture Summary

### System Components

**Native Server:**
- Multi-transport (TCP + WebRTC)
- Always-on network backbone
- Full DHT participant
- Relay for browser nodes

**WASM Client:**
- Browser-compatible
- WebRTC/WebSocket transport
- Local storage for caching
- Offline-first operation

**Web Interface:**
- User interaction layer
- Connection management
- Real-time status
- Message sending/receiving

### Data Flow

**Write Operation:**
1. User creates/updates data locally
2. Data signed with private key
3. Published to topic via GossipSub
4. Propagates through DHT
5. Replicated to responsible nodes
6. Other clients receive and merge via CRDT

**Read Operation:**
1. Look up soul in local cache
2. If not found, query DHT
3. Retrieve from responsible nodes
4. Cache locally
5. Return to application

### Security Model

**Data Classification:**
- Public: Readable by all, writable by all (unless signed)
- Protected: Readable by all, writable by owner
- Private: Encrypted, accessible only to authorized

**Cryptographic Primitives:**
- Ed25519 for signatures
- Hash-based content addressing
- Encryption for private data (future)

## Performance Targets

From the PRD:

**Latency:**
- Sub-100ms for basic operations
- Comparable to Holochain benchmarks (50ms write, 30ms read)

**Throughput:**
- 10-20 TPS minimum per node
- Scales with network size

**Resource Usage:**
- Minimal CPU and memory footprint
- Critical for browser nodes
- Rust + WASM optimization

## What This Enables

### Practical Applications

**Offline-First Collaboration:**
- Edit documents offline
- Automatic sync when online
- No merge conflicts

**Decentralized Chat:**
- No central message server
- Direct P2P communication
- Message history distributed

**Local-First Applications:**
- Data primarily on user device
- Cloud as backup/sync
- Privacy by default

**IoT Edge Computing:**
- Distributed sensor data
- No cloud dependency
- Resilient to network partitions

## Conclusion

RustDHT's technical stack combines:
- Proven patterns (DHT, CRDT, graph model)
- Modern implementation (Rust, WASM, libp2p)
- Practical design (acknowledges constraints)
- Production focus (deployment, monitoring)

The architecture demonstrates that decentralized systems can be both theoretically sound and pragmatically implementable. By building on established projects (especially GunDB) while leveraging modern tooling, RustDHT offers a path to high-performance, browser-native P2P applications.

The next document explores specific use cases and examples to illustrate what becomes possible with this technology.

## Further Reading

### Internal Documentation
- `README.md` - Features and getting started
- `docs/arch/main_architecture.md` - Detailed architecture
- `docs/PRD for Decentralized Graph Database_.md` - Comprehensive technical specification
- `docs/libp2p-browser-communication.md` - WebRTC implementation details
- `docs/project-progress-report.md` - Current status

### Source Code
- `src/bin/server.rs` - Native server implementation
- `src/lib.rs` - WASM client implementation
- `Cargo.toml` - Dependencies and configuration

### External Resources
- libp2p documentation: [https://docs.libp2p.io/]
- GunDB documentation: [https://gun.eco/docs/]
- Rust WebAssembly book: [https://rustwasm.github.io/]
- CRDT resources: Academic papers and implementation libraries

